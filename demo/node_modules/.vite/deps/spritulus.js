import "./chunk-BUSYA2B4.js";

// node_modules/spritulus/dist/index.module.js
function e(e2) {
  var t2 = { exports: {} };
  return e2(t2, t2.exports), t2.exports;
}
var t = Symbol.for("react.transitional.element");
var n = Symbol.for("react.portal");
var r = Symbol.for("react.fragment");
var o = Symbol.for("react.strict_mode");
var a = Symbol.for("react.profiler");
var u = Symbol.for("react.consumer");
var s = Symbol.for("react.context");
var i = Symbol.for("react.forward_ref");
var c = Symbol.for("react.suspense");
var l = Symbol.for("react.memo");
var f = Symbol.for("react.lazy");
var p = Symbol.for("react.activity");
var y = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} };
var m = Object.assign;
var b = {};
function _(e2, t2, n2) {
  this.props = e2, this.context = t2, this.refs = b, this.updater = n2 || y;
}
function v() {
}
function g(e2, t2, n2) {
  this.props = e2, this.context = t2, this.refs = b, this.updater = n2 || y;
}
_.prototype.isReactComponent = {}, _.prototype.setState = function(e2, t2) {
  if ("object" != typeof e2 && "function" != typeof e2 && null != e2) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, e2, t2, "setState");
}, _.prototype.forceUpdate = function(e2) {
  this.updater.enqueueForceUpdate(this, e2, "forceUpdate");
}, v.prototype = _.prototype;
var w = g.prototype = new v();
w.constructor = g, m(w, _.prototype), w.isPureReactComponent = true;
var H = e(function(e2, t2) {
  (function() {
    function n2(e3, t3) {
      Object.defineProperty(o2.prototype, e3, { get: function() {
        console.warn("%s(...) is deprecated in plain JavaScript React classes. %s", t3[0], t3[1]);
      } });
    }
    function r2(e3, t3) {
      var n3 = (e3 = (e3 = e3.constructor) && (e3.displayName || e3.name) || "ReactClass") + "." + t3;
      F[n3] || (console.error("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", t3, e3), F[n3] = true);
    }
    function o2(e3, t3, n3) {
      this.props = e3, this.context = t3, this.refs = G, this.updater = n3 || Y;
    }
    function a2() {
    }
    function u2(e3, t3, n3) {
      this.props = e3, this.context = t3, this.refs = G, this.updater = n3 || Y;
    }
    function s2() {
    }
    function i2(e3) {
      return "" + e3;
    }
    function c2(e3) {
      try {
        i2(e3);
        var t3 = false;
      } catch (e4) {
        t3 = true;
      }
      if (t3) {
        t3 = console;
        var n3 = "function" == typeof Symbol && Symbol.toStringTag && e3[Symbol.toStringTag] || e3.constructor.name || "Object";
        return t3.error.call(t3, "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.", n3), i2(e3);
      }
    }
    function l2(e3) {
      if (null == e3) return null;
      if ("function" == typeof e3) return e3.$$typeof === X ? null : e3.displayName || e3.name || null;
      if ("string" == typeof e3) return e3;
      switch (e3) {
        case I:
          return "Fragment";
        case P:
          return "Profiler";
        case A:
          return "StrictMode";
        case M:
          return "Suspense";
        case D:
          return "SuspenseList";
        case q:
          return "Activity";
      }
      if ("object" == typeof e3) switch ("number" == typeof e3.tag && console.error("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), e3.$$typeof) {
        case $:
          return "Portal";
        case N2:
          return e3.displayName || "Context";
        case H2:
          return (e3._context.displayName || "Context") + ".Consumer";
        case L2:
          var t3 = e3.render;
          return (e3 = e3.displayName) || (e3 = "" !== (e3 = t3.displayName || t3.name || "") ? "ForwardRef(" + e3 + ")" : "ForwardRef"), e3;
        case U:
          return null !== (t3 = e3.displayName || null) ? t3 : l2(e3.type) || "Memo";
        case z:
          t3 = e3._payload, e3 = e3._init;
          try {
            return l2(e3(t3));
          } catch (e4) {
          }
      }
      return null;
    }
    function f2(e3) {
      if (e3 === I) return "<>";
      if ("object" == typeof e3 && null !== e3 && e3.$$typeof === z) return "<...>";
      try {
        var t3 = l2(e3);
        return t3 ? "<" + t3 + ">" : "<...>";
      } catch (e4) {
        return "<...>";
      }
    }
    function p2() {
      var e3 = Z.A;
      return null === e3 ? null : e3.getOwner();
    }
    function d() {
      return Error("react-stack-top-frame");
    }
    function y2(e3) {
      if (ee.call(e3, "key")) {
        var t3 = Object.getOwnPropertyDescriptor(e3, "key").get;
        if (t3 && t3.isReactWarning) return false;
      }
      return void 0 !== e3.key;
    }
    function h2() {
      var e3 = l2(this.type);
      return ne[e3] || (ne[e3] = true, console.error("Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.")), void 0 !== (e3 = this.props.ref) ? e3 : null;
    }
    function m2(e3, t3, n3, r3, o3, a3) {
      var u3 = n3.ref;
      return e3 = { $$typeof: x, type: e3, key: t3, props: n3, _owner: r3 }, Object.defineProperty(e3, "ref", null !== (void 0 !== u3 ? u3 : null) ? { enumerable: false, get: h2 } : { enumerable: false, value: null }), e3._store = {}, Object.defineProperty(e3._store, "validated", { configurable: false, enumerable: false, writable: true, value: 0 }), Object.defineProperty(e3, "_debugInfo", { configurable: false, enumerable: false, writable: true, value: null }), Object.defineProperty(e3, "_debugStack", { configurable: false, enumerable: false, writable: true, value: o3 }), Object.defineProperty(e3, "_debugTask", { configurable: false, enumerable: false, writable: true, value: a3 }), Object.freeze && (Object.freeze(e3.props), Object.freeze(e3)), e3;
    }
    function b2(e3) {
      _2(e3) ? e3._store && (e3._store.validated = 1) : "object" == typeof e3 && null !== e3 && e3.$$typeof === z && ("fulfilled" === e3._payload.status ? _2(e3._payload.value) && e3._payload.value._store && (e3._payload.value._store.validated = 1) : e3._store && (e3._store.validated = 1));
    }
    function _2(e3) {
      return "object" == typeof e3 && null !== e3 && e3.$$typeof === x;
    }
    function v2(e3, t3) {
      return "object" == typeof e3 && null !== e3 && null != e3.key ? (c2(e3.key), n3 = { "=": "=0", ":": "=2" }, "$" + ("" + e3.key).replace(/[=:]/g, function(e4) {
        return n3[e4];
      })) : t3.toString(36);
      var n3;
    }
    function g2(e3, t3, n3, r3, o3) {
      var a3 = typeof e3;
      "undefined" !== a3 && "boolean" !== a3 || (e3 = null);
      var u3, i3, l3, f3 = false;
      if (null === e3) f3 = true;
      else switch (a3) {
        case "bigint":
        case "string":
        case "number":
          f3 = true;
          break;
        case "object":
          switch (e3.$$typeof) {
            case x:
            case $:
              f3 = true;
              break;
            case z:
              return g2((f3 = e3._init)(e3._payload), t3, n3, r3, o3);
          }
      }
      if (f3) {
        o3 = o3(f3 = e3);
        var p3 = "" === r3 ? "." + v2(f3, 0) : r3;
        return J(o3) ? (n3 = "", null != p3 && (n3 = p3.replace(ue, "$&/") + "/"), g2(o3, t3, n3, "", function(e4) {
          return e4;
        })) : null != o3 && (_2(o3) && (null != o3.key && (f3 && f3.key === o3.key || c2(o3.key)), u3 = o3, i3 = n3 + (null == o3.key || f3 && f3.key === o3.key ? "" : ("" + o3.key).replace(ue, "$&/") + "/") + p3, i3 = m2(u3.type, i3, u3.props, u3._owner, u3._debugStack, u3._debugTask), u3._store && (i3._store.validated = u3._store.validated), n3 = i3, "" !== r3 && null != f3 && _2(f3) && null == f3.key && f3._store && !f3._store.validated && (n3._store.validated = 2), o3 = n3), t3.push(o3)), 1;
      }
      if (f3 = 0, p3 = "" === r3 ? "." : r3 + ":", J(e3)) for (var d2 = 0; d2 < e3.length; d2++) f3 += g2(r3 = e3[d2], t3, n3, a3 = p3 + v2(r3, d2), o3);
      else if ("function" == typeof (d2 = null === (l3 = e3) || "object" != typeof l3 ? null : "function" == typeof (l3 = V && l3[V] || l3["@@iterator"]) ? l3 : null)) for (d2 === e3.entries && (ae || console.warn("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), ae = true), e3 = d2.call(e3), d2 = 0; !(r3 = e3.next()).done; ) f3 += g2(r3 = r3.value, t3, n3, a3 = p3 + v2(r3, d2++), o3);
      else if ("object" === a3) {
        if ("function" == typeof e3.then) return g2((function(e4) {
          switch (e4.status) {
            case "fulfilled":
              return e4.value;
            case "rejected":
              throw e4.reason;
            default:
              switch ("string" == typeof e4.status ? e4.then(s2, s2) : (e4.status = "pending", e4.then(function(t4) {
                "pending" === e4.status && (e4.status = "fulfilled", e4.value = t4);
              }, function(t4) {
                "pending" === e4.status && (e4.status = "rejected", e4.reason = t4);
              })), e4.status) {
                case "fulfilled":
                  return e4.value;
                case "rejected":
                  throw e4.reason;
              }
          }
          throw e4;
        })(e3), t3, n3, r3, o3);
        throw t3 = String(e3), Error("Objects are not valid as a React child (found: " + ("[object Object]" === t3 ? "object with keys {" + Object.keys(e3).join(", ") + "}" : t3) + "). If you meant to render a collection of children, use an array instead.");
      }
      return f3;
    }
    function w2(e3, t3, n3) {
      if (null == e3) return e3;
      var r3 = [], o3 = 0;
      return g2(e3, r3, "", "", function(e4) {
        return t3.call(n3, e4, o3++);
      }), r3;
    }
    function S(e3) {
      if (-1 === e3._status) {
        var t3 = e3._ioInfo;
        null != t3 && (t3.start = t3.end = performance.now());
        var n3 = (t3 = e3._result)();
        if (n3.then(function(t4) {
          if (0 === e3._status || -1 === e3._status) {
            e3._status = 1, e3._result = t4;
            var r4 = e3._ioInfo;
            null != r4 && (r4.end = performance.now()), void 0 === n3.status && (n3.status = "fulfilled", n3.value = t4);
          }
        }, function(t4) {
          if (0 === e3._status || -1 === e3._status) {
            e3._status = 2, e3._result = t4;
            var r4 = e3._ioInfo;
            null != r4 && (r4.end = performance.now()), void 0 === n3.status && (n3.status = "rejected", n3.reason = t4);
          }
        }), null != (t3 = e3._ioInfo)) {
          t3.value = n3;
          var r3 = n3.displayName;
          "string" == typeof r3 && (t3.name = r3);
        }
        -1 === e3._status && (e3._status = 0, e3._result = n3);
      }
      if (1 === e3._status) return void 0 === (t3 = e3._result) && console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))\n\nDid you accidentally put curly braces around the import?", t3), "default" in t3 || console.error("lazy: Expected the result of a dynamic import() call. Instead received: %s\n\nYour code should look like: \n  const MyComponent = lazy(() => import('./MyComponent'))", t3), t3.default;
      throw e3._result;
    }
    function E() {
      var e3 = Z.H;
      return null === e3 && console.error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem."), e3;
    }
    function k() {
      Z.asyncTransitions--;
    }
    function O(t3) {
      if (null === ce) try {
        var n3 = ("require" + Math.random()).slice(0, 7);
        ce = (e2 && e2[n3]).call(e2, "timers").setImmediate;
      } catch (e3) {
        ce = function(e4) {
          false === ie && (ie = true, "undefined" == typeof MessageChannel && console.error("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
          var t4 = new MessageChannel();
          t4.port1.onmessage = e4, t4.port2.postMessage(void 0);
        };
      }
      return ce(t3);
    }
    function R(e3) {
      return 1 < e3.length && "function" == typeof AggregateError ? new AggregateError(e3) : e3[0];
    }
    function j(e3, t3) {
      t3 !== le - 1 && console.error("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), le = t3;
    }
    function C(e3, t3, n3) {
      var r3 = Z.actQueue;
      if (null !== r3) if (0 !== r3.length) try {
        return T(r3), void O(function() {
          return C(e3, t3, n3);
        });
      } catch (e4) {
        Z.thrownErrors.push(e4);
      }
      else Z.actQueue = null;
      0 < Z.thrownErrors.length ? (r3 = R(Z.thrownErrors), Z.thrownErrors.length = 0, n3(r3)) : t3(e3);
    }
    function T(e3) {
      if (!pe) {
        pe = true;
        var t3 = 0;
        try {
          for (; t3 < e3.length; t3++) for (var n3 = e3[t3]; ; ) {
            Z.didUsePromise = false;
            var r3 = n3(false);
            if (null === r3) break;
            if (Z.didUsePromise) return e3[t3] = n3, void e3.splice(0, t3);
            n3 = r3;
          }
          e3.length = 0;
        } catch (n4) {
          e3.splice(0, t3 + 1), Z.thrownErrors.push(n4);
        } finally {
          pe = false;
        }
      }
    }
    "undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
    var x = Symbol.for("react.transitional.element"), $ = Symbol.for("react.portal"), I = Symbol.for("react.fragment"), A = Symbol.for("react.strict_mode"), P = Symbol.for("react.profiler"), H2 = Symbol.for("react.consumer"), N2 = Symbol.for("react.context"), L2 = Symbol.for("react.forward_ref"), M = Symbol.for("react.suspense"), D = Symbol.for("react.suspense_list"), U = Symbol.for("react.memo"), z = Symbol.for("react.lazy"), q = Symbol.for("react.activity"), V = Symbol.iterator, F = {}, Y = { isMounted: function() {
      return false;
    }, enqueueForceUpdate: function(e3) {
      r2(e3, "forceUpdate");
    }, enqueueReplaceState: function(e3) {
      r2(e3, "replaceState");
    }, enqueueSetState: function(e3) {
      r2(e3, "setState");
    } }, B = Object.assign, G = {};
    Object.freeze(G), o2.prototype.isReactComponent = {}, o2.prototype.setState = function(e3, t3) {
      if ("object" != typeof e3 && "function" != typeof e3 && null != e3) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, e3, t3, "setState");
    }, o2.prototype.forceUpdate = function(e3) {
      this.updater.enqueueForceUpdate(this, e3, "forceUpdate");
    };
    var W = { isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."], replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."] };
    for (ye in W) W.hasOwnProperty(ye) && n2(ye, W[ye]);
    a2.prototype = o2.prototype, (W = u2.prototype = new a2()).constructor = u2, B(W, o2.prototype), W.isPureReactComponent = true;
    var Q, K, J = Array.isArray, X = Symbol.for("react.client.reference"), Z = { H: null, A: null, T: null, S: null, actQueue: null, asyncTransitions: 0, isBatchingLegacy: false, didScheduleLegacyUpdate: false, didUsePromise: false, thrownErrors: [], getCurrentStack: null, recentlyCreatedOwnerStacks: 0 }, ee = Object.prototype.hasOwnProperty, te = console.createTask ? console.createTask : function() {
      return null;
    }, ne = {}, re = (W = { react_stack_bottom_frame: function(e3) {
      return e3();
    } }).react_stack_bottom_frame.bind(W, d)(), oe = te(f2(d)), ae = false, ue = /\/+/g, se = "function" == typeof reportError ? reportError : function(e3) {
      if ("object" == typeof window && "function" == typeof window.ErrorEvent) {
        var t3 = new window.ErrorEvent("error", { bubbles: true, cancelable: true, message: String("object" == typeof e3 && null !== e3 && "string" == typeof e3.message ? e3.message : e3), error: e3 });
        if (!window.dispatchEvent(t3)) return;
      } else if ("object" == typeof process && "function" == typeof process.emit) return void process.emit("uncaughtException", e3);
      console.error(e3);
    }, ie = false, ce = null, le = 0, fe = false, pe = false, de = "function" == typeof queueMicrotask ? function(e3) {
      queueMicrotask(function() {
        return queueMicrotask(e3);
      });
    } : O;
    W = Object.freeze({ __proto__: null, c: function(e3) {
      return E().useMemoCache(e3);
    } });
    var ye = { map: w2, forEach: function(e3, t3, n3) {
      w2(e3, function() {
        t3.apply(this, arguments);
      }, n3);
    }, count: function(e3) {
      var t3 = 0;
      return w2(e3, function() {
        t3++;
      }), t3;
    }, toArray: function(e3) {
      return w2(e3, function(e4) {
        return e4;
      }) || [];
    }, only: function(e3) {
      if (!_2(e3)) throw Error("React.Children.only expected to receive a single React element child.");
      return e3;
    } };
    t2.Activity = q, t2.Children = ye, t2.Component = o2, t2.Fragment = I, t2.Profiler = P, t2.PureComponent = u2, t2.StrictMode = A, t2.Suspense = M, t2.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Z, t2.__COMPILER_RUNTIME = W, t2.act = function(e3) {
      var t3 = Z.actQueue, n3 = le;
      le++;
      var r3 = Z.actQueue = null !== t3 ? t3 : [], o3 = false;
      try {
        var a3 = e3();
      } catch (e4) {
        Z.thrownErrors.push(e4);
      }
      if (0 < Z.thrownErrors.length) throw j(0, n3), e3 = R(Z.thrownErrors), Z.thrownErrors.length = 0, e3;
      if (null !== a3 && "object" == typeof a3 && "function" == typeof a3.then) {
        var u3 = a3;
        return de(function() {
          o3 || fe || (fe = true, console.error("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
        }), { then: function(e4, t4) {
          o3 = true, u3.then(function(o4) {
            if (j(0, n3), 0 === n3) {
              try {
                T(r3), O(function() {
                  return C(o4, e4, t4);
                });
              } catch (e5) {
                Z.thrownErrors.push(e5);
              }
              if (0 < Z.thrownErrors.length) {
                var a4 = R(Z.thrownErrors);
                Z.thrownErrors.length = 0, t4(a4);
              }
            } else e4(o4);
          }, function(e5) {
            j(0, n3), 0 < Z.thrownErrors.length ? (e5 = R(Z.thrownErrors), Z.thrownErrors.length = 0, t4(e5)) : t4(e5);
          });
        } };
      }
      var s3 = a3;
      if (j(0, n3), 0 === n3 && (T(r3), 0 !== r3.length && de(function() {
        o3 || fe || (fe = true, console.error("A component suspended inside an `act` scope, but the `act` call was not awaited. When testing React components that depend on asynchronous data, you must await the result:\n\nawait act(() => ...)"));
      }), Z.actQueue = null), 0 < Z.thrownErrors.length) throw e3 = R(Z.thrownErrors), Z.thrownErrors.length = 0, e3;
      return { then: function(e4, t4) {
        o3 = true, 0 === n3 ? (Z.actQueue = r3, O(function() {
          return C(s3, e4, t4);
        })) : e4(s3);
      } };
    }, t2.cache = function(e3) {
      return function() {
        return e3.apply(null, arguments);
      };
    }, t2.cacheSignal = function() {
      return null;
    }, t2.captureOwnerStack = function() {
      var e3 = Z.getCurrentStack;
      return null === e3 ? null : e3();
    }, t2.cloneElement = function(e3, t3, n3) {
      if (null == e3) throw Error("The argument must be a React element, but you passed " + e3 + ".");
      var r3, o3 = B({}, e3.props), a3 = e3.key, u3 = e3._owner;
      if (null != t3) for (s3 in (r3 = !(ee.call(t3, "ref") && (r3 = Object.getOwnPropertyDescriptor(t3, "ref").get) && r3.isReactWarning) && void 0 !== t3.ref) && (u3 = p2()), y2(t3) && (c2(t3.key), a3 = "" + t3.key), t3) !ee.call(t3, s3) || "key" === s3 || "__self" === s3 || "__source" === s3 || "ref" === s3 && void 0 === t3.ref || (o3[s3] = t3[s3]);
      var s3 = arguments.length - 2;
      if (1 === s3) o3.children = n3;
      else if (1 < s3) {
        r3 = Array(s3);
        for (var i3 = 0; i3 < s3; i3++) r3[i3] = arguments[i3 + 2];
        o3.children = r3;
      }
      for (o3 = m2(e3.type, a3, o3, u3, e3._debugStack, e3._debugTask), a3 = 2; a3 < arguments.length; a3++) b2(arguments[a3]);
      return o3;
    }, t2.createContext = function(e3) {
      return (e3 = { $$typeof: N2, _currentValue: e3, _currentValue2: e3, _threadCount: 0, Provider: null, Consumer: null }).Provider = e3, e3.Consumer = { $$typeof: H2, _context: e3 }, e3._currentRenderer = null, e3._currentRenderer2 = null, e3;
    }, t2.createElement = function(e3, t3, n3) {
      for (var r3 = 2; r3 < arguments.length; r3++) b2(arguments[r3]);
      r3 = {};
      var o3 = null;
      if (null != t3) for (i3 in K || !("__self" in t3) || "key" in t3 || (K = true, console.warn("Your app (or one of its dependencies) is using an outdated JSX transform. Update to the modern JSX transform for faster performance: https://react.dev/link/new-jsx-transform")), y2(t3) && (c2(t3.key), o3 = "" + t3.key), t3) ee.call(t3, i3) && "key" !== i3 && "__self" !== i3 && "__source" !== i3 && (r3[i3] = t3[i3]);
      var a3 = arguments.length - 2;
      if (1 === a3) r3.children = n3;
      else if (1 < a3) {
        for (var u3 = Array(a3), s3 = 0; s3 < a3; s3++) u3[s3] = arguments[s3 + 2];
        Object.freeze && Object.freeze(u3), r3.children = u3;
      }
      if (e3 && e3.defaultProps) for (i3 in a3 = e3.defaultProps) void 0 === r3[i3] && (r3[i3] = a3[i3]);
      o3 && (function(e4, t4) {
        function n4() {
          Q || (Q = true, console.error("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)", t4));
        }
        n4.isReactWarning = true, Object.defineProperty(e4, "key", { get: n4, configurable: true });
      })(r3, "function" == typeof e3 ? e3.displayName || e3.name || "Unknown" : e3);
      var i3 = 1e4 > Z.recentlyCreatedOwnerStacks++;
      return m2(e3, o3, r3, p2(), i3 ? Error("react-stack-top-frame") : re, i3 ? te(f2(e3)) : oe);
    }, t2.createRef = function() {
      var e3 = { current: null };
      return Object.seal(e3), e3;
    }, t2.forwardRef = function(e3) {
      null != e3 && e3.$$typeof === U ? console.error("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : "function" != typeof e3 ? console.error("forwardRef requires a render function but was given %s.", null === e3 ? "null" : typeof e3) : 0 !== e3.length && 2 !== e3.length && console.error("forwardRef render functions accept exactly two parameters: props and ref. %s", 1 === e3.length ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), null != e3 && null != e3.defaultProps && console.error("forwardRef render functions do not support defaultProps. Did you accidentally pass a React component?");
      var t3, n3 = { $$typeof: L2, render: e3 };
      return Object.defineProperty(n3, "displayName", { enumerable: false, configurable: true, get: function() {
        return t3;
      }, set: function(n4) {
        t3 = n4, e3.name || e3.displayName || (Object.defineProperty(e3, "name", { value: n4 }), e3.displayName = n4);
      } }), n3;
    }, t2.isValidElement = _2, t2.lazy = function(e3) {
      var t3 = { $$typeof: z, _payload: e3 = { _status: -1, _result: e3 }, _init: S }, n3 = { name: "lazy", start: -1, end: -1, value: null, owner: null, debugStack: Error("react-stack-top-frame"), debugTask: console.createTask ? console.createTask("lazy()") : null };
      return e3._ioInfo = n3, t3._debugInfo = [{ awaited: n3 }], t3;
    }, t2.memo = function(e3, t3) {
      var n3;
      return null == e3 && console.error("memo: The first argument must be a component. Instead received: %s", null === e3 ? "null" : typeof e3), t3 = { $$typeof: U, type: e3, compare: void 0 === t3 ? null : t3 }, Object.defineProperty(t3, "displayName", { enumerable: false, configurable: true, get: function() {
        return n3;
      }, set: function(t4) {
        n3 = t4, e3.name || e3.displayName || (Object.defineProperty(e3, "name", { value: t4 }), e3.displayName = t4);
      } }), t3;
    }, t2.startTransition = function(e3) {
      var t3 = Z.T, n3 = {};
      n3._updatedFibers = /* @__PURE__ */ new Set(), Z.T = n3;
      try {
        var r3 = e3(), o3 = Z.S;
        null !== o3 && o3(n3, r3), "object" == typeof r3 && null !== r3 && "function" == typeof r3.then && (Z.asyncTransitions++, r3.then(k, k), r3.then(s2, se));
      } catch (e4) {
        se(e4);
      } finally {
        null === t3 && n3._updatedFibers && (e3 = n3._updatedFibers.size, n3._updatedFibers.clear(), 10 < e3 && console.warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table.")), null !== t3 && null !== n3.types && (null !== t3.types && t3.types !== n3.types && console.error("We expected inner Transitions to have transferred the outer types set and that you cannot add to the outer Transition while inside the inner.This is a bug in React."), t3.types = n3.types), Z.T = t3;
      }
    }, t2.unstable_useCacheRefresh = function() {
      return E().useCacheRefresh();
    }, t2.use = function(e3) {
      return E().use(e3);
    }, t2.useActionState = function(e3, t3, n3) {
      return E().useActionState(e3, t3, n3);
    }, t2.useCallback = function(e3, t3) {
      return E().useCallback(e3, t3);
    }, t2.useContext = function(e3) {
      var t3 = E();
      return e3.$$typeof === H2 && console.error("Calling useContext(Context.Consumer) is not supported and will cause bugs. Did you mean to call useContext(Context) instead?"), t3.useContext(e3);
    }, t2.useDebugValue = function(e3, t3) {
      return E().useDebugValue(e3, t3);
    }, t2.useDeferredValue = function(e3, t3) {
      return E().useDeferredValue(e3, t3);
    }, t2.useEffect = function(e3, t3) {
      return null == e3 && console.warn("React Hook useEffect requires an effect callback. Did you forget to pass a callback to the hook?"), E().useEffect(e3, t3);
    }, t2.useEffectEvent = function(e3) {
      return E().useEffectEvent(e3);
    }, t2.useId = function() {
      return E().useId();
    }, t2.useImperativeHandle = function(e3, t3, n3) {
      return E().useImperativeHandle(e3, t3, n3);
    }, t2.useInsertionEffect = function(e3, t3) {
      return null == e3 && console.warn("React Hook useInsertionEffect requires an effect callback. Did you forget to pass a callback to the hook?"), E().useInsertionEffect(e3, t3);
    }, t2.useLayoutEffect = function(e3, t3) {
      return null == e3 && console.warn("React Hook useLayoutEffect requires an effect callback. Did you forget to pass a callback to the hook?"), E().useLayoutEffect(e3, t3);
    }, t2.useMemo = function(e3, t3) {
      return E().useMemo(e3, t3);
    }, t2.useOptimistic = function(e3, t3) {
      return E().useOptimistic(e3, t3);
    }, t2.useReducer = function(e3, t3, n3) {
      return E().useReducer(e3, t3, n3);
    }, t2.useRef = function(e3) {
      return E().useRef(e3);
    }, t2.useState = function(e3) {
      return E().useState(e3);
    }, t2.useSyncExternalStore = function(e3, t3, n3) {
      return E().useSyncExternalStore(e3, t3, n3);
    }, t2.useTransition = function() {
      return E().useTransition();
    }, t2.version = "19.2.0", "undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
  })();
});
var N = e(function(e2) {
  e2.exports = false ? P : H;
});
function L(e2) {
  var t2 = e2.id, n2 = e2.animationName, r2 = e2.flipped, o2 = void 0 !== r2 && r2, a2 = N.useRef(null), u2 = N.useState(0), s2 = u2[0], i2 = u2[1], c2 = N.useState(0), l2 = c2[0], f2 = c2[1], p2 = N.useState(200), d = p2[0], y2 = p2[1], m2 = N.useState(200), b2 = m2[0], _2 = m2[1], v2 = N.useState(null), g2 = v2[0], w2 = v2[1], S = N.useState(null), E = S[0], k = S[1], O = N.useState(o2), R = O[0], j = O[1];
  return N.useEffect(function() {
    g2 || fetch("/sprite-" + t2 + ".json").then(function(e3) {
      return e3.json();
    }).then(function(e3) {
      var t3 = e3.animations.findIndex(function(e4) {
        return e4.name.toLowerCase() === n2.toLowerCase();
      });
      t3 < 0 && (t3 = 0), y2(e3.size.height), _2(e3.size.width), k(e3.animations[t3] || e3.animations[0]), f2(t3 * e3.size.height + (R ? e3.animations.length * e3.size.height : 0)), w2(e3);
    });
  }, [t2]), N.useEffect(function() {
    var e3 = function() {
      !E || E.frames <= 1 || (i2(b2 * (t3 = (t3 + 1) % E.frames)), a2.current = setTimeout(e3, 128));
    }, t3 = 0;
    return g2 && e3(), function() {
      clearTimeout(a2.current);
    };
  }, [g2, E, d, b2]), N.useEffect(function() {
    j(o2);
  }, [o2]), N.useEffect(function() {
    if (g2) {
      var e3 = g2.animations.findIndex(function(e4) {
        return e4.name.toLowerCase() === n2.toLowerCase();
      });
      e3 < 0 && (e3 = 0), k(g2.animations[e3] || g2.animations[0]), f2(e3 * g2.size.height + (R ? g2.animations.length * g2.size.height : 0));
    }
  }, [n2, R, g2]), h("div", { style: { width: b2 + "px", height: d + "px", overflow: "hidden", backgroundPosition: s2 + "px " + -l2 + "px", backgroundImage: "url('/sprite-" + t2 + ".png')" } });
}
export {
  L as default
};
//# sourceMappingURL=spritulus.js.map
